# Aggregate Functions（聚合函數）

用於對多筆紀錄的值進行一些運算，進而得到一個數值。

- 常用的聚合函數（近乎可以涵蓋 9 成實務情境）包括:

- `SUM()`: 計算符合條件的紀錄總和
- `COUNT()`: 計算符合條件的紀錄數量
- `AVG()`: 計算符合條件的紀錄平均值
- `MIN()`: 計算符合條件的紀錄中的最小值
- `MAX()`: 計算符合條件的紀錄中的最大值
- `ROUND()`: 四捨五入到第幾位小數

- 練習：

```sql
-- 計算 payment 總金額
SELECT SUM(amount) FROM payment;

-- 計算 payment 總筆數
SELECT COUNT(*) FROM payment;

-- 計算 payment 平均金額
SELECT AVG(amount) FROM payment;

-- 計算 payment 最大金額
SELECT MAX(amount) FROM payment;

-- 計算 payment 最小金額
SELECT MIN(amount) FROM payment;

-- 多個聚合函數一同使用
SELECT 
    SUM(amount), 
    COUNT(*), 
    ROUND(AVG(amount), 3), 
    MAX(amount), 
    MIN(amount) 
FROM payment;

-- 聚合函數是不可能與非聚合函數一起使用的，因為聚合函數僅產生一個值，而非聚合函數則可能產生多個值
-- 唯一的例外是對資料進行分組，下面將會介紹這種用法
```

- **挑戰 1 - UDEMY**:

Your challenge is to write a single SQL query to find the total number of orders and the average order amount from the `Orders` table. The solution should include only orders made in August 2023.

Use the aliases TotalOrders and AverageOrderAmount in your query.

**Column names:**

- `OrderID`
- `Amount`
- `OrderDate`

Remember, you know how to use `COUNT()`, `AVG()`, `WHERE`, `BETWEEN`, and other basic SQL commands without grouping.

<details>
    <summary>參考答案</summary>

```sql
SELECT 
    COUNT(*) AS TotalOrders,
    AVG(amount) AS AverageOrderAmount
FROM 
    Orders
WHERE 
    OrderDate BETWEEN '2023-08-01' AND '2023-08-31 23:59:59';

-- Ans:
-- TotalOrders	AverageOrderAmount
-- 5	410
```
</details>

<br/>

- **挑戰 2**:

你的經理想要一個更容易理解電影（`films`）重置成本（`replacement cost`）的相關資訊，你需要使用一筆 SQL 查詢來取得以下資訊:

- 最低重置成本的電影
- 最高重置成本的電影
- 電影重置成本的平均值（四捨五入到第二位小數）
- 電影重置成本的總和

<details>
    <summary>參考答案</summary>

```sql
SELECT
    MIN(replacement_cost),
    MAX(replacement_cost),
    ROUND(AVG(replacement_cost), 2) AS average, 
    SUM(replacement_cost)
FROM film;
```

</details>

<br/>

# GROUP BY

用於對多筆紀錄進行分組，以便對每一個分組進行聚合操作，通常與聚合函數一同使用。

- 用法:

```sql
-- 當聚合函數被使用時，任一選擇的欄位必須在聚合函數內或是在 GROUP BY 語句中
SELECT <column_name> FROM <table_name> GROUP BY <column_name>;
```

- 練習:

```sql
-- 計算 customer id > 3 的各個客戶 payment 總金額
SELECT 
    customer_id, 
    SUM(amount) 
FROM payment
WHERE customer_id > 3
GROUP BY customer_id;
```

- **挑戰 1 - UDEMY**:

Using the `sales_data` table, write a SQL query to calculate the total `quantity` sold and the total `sale_amount` for each `category`.

Your query should return columns for the `category`, the sum of `quantity` as `total_quantity`, and the sum of `sale_amount` as `total_sales_amount`. Order the results by `total_sales_amount` in descending order.

Important columns:

- `category`
- `quantity`
- `sale_amount`

<details>
    <summary>參考答案</summary>

```sql
SELECT
    category,
    SUM(quantity) AS total_quantity,
    SUM(sale_amount) AS total_sales_amount
FROM sales_data
GROUP BY category
ORDER BY total_sales_amount DESC;
```

</details>

<br/>

- **挑戰 2**:

你的經理想要確認兩個員工（`employees`）（`staff_id`）誰負責較多的帳單?他們誰支付較多的金額（`amount`）?

若是將金額（`amount`）為 `0` 的帳單排除，上面的搜尋會變成什麼樣子呢？

**NOTE**: 注意此題需先確認要查詢哪個表，並需完成兩個查詢。

<details>
    <summary>2-1. 參考答案</summary>

```sql
SELECT
    staff_id,
	COUNT(amount),
	SUM(amount)
FROM payment
GROUP BY staff_id
ORDER BY COUNT(amount) DESC;

-- Ans:(不一定要排序)
-- staff_id	count	sum
-- 1	8057	33489.47
-- 2	7992	33927.04
```
</details>

<br/>

<details>
    <summary>2-2. 參考答案</summary>

```sql
SELECT
    staff_id,
	COUNT(amount),
	SUM(amount)
FROM payment
WHERE amount <> 0
GROUP BY staff_id
ORDER BY COUNT(amount) DESC;

-- Ans:(不一定要排序)
-- staff_id	count	sum
-- 1	8042	33489.47
-- 2	7983	33927.04
```
</details>

<br/>

# GROUP BY - 多個欄位

當 `GROUP BY` 語句中有多個欄位時，會將這些欄位看作是一個整體，並將這些欄位的值作為分組的依據。

```sql
SELECT
    staff_id,
    customer_id,
    SUM(amount),
    COUNT(amount)
FROM payment
GROUP BY
    staff_id,
    customer_id;

-- 以此查詢為例，代表將 `staff_id` 和 `customer_id` 當作一個整體來看待，將這些欄位的值作為分組的依據。
```

- **挑戰 1 - UDEMY**:

Create a query showing the total sales amount (AS total_sales_amount) and total number of items sold  (AS total_items_sold), grouped by `category` and `sale_date`. Order the results by `category` in ascending order and then by `sale_date` in ascending order.

Use the `sales` table with columns: `category`, `sale_date`, `amount`.

Note: You can assume one row in the table represents one item sold.

<details>
    <summary>參考答案</summary>

```sql
SELECT
  category,
  sale_date,
  COUNT(*) AS total_items_sold,
  SUM(amount) AS total_sales_amount
FROM sales
GROUP BY
  category,
  sale_date
ORDER BY
  category ASC,
  sale_date ASC;
```

</details>

<br/>

- **挑戰 2**:

有兩個員工是主要競爭者，我們想知道哪一個員工有最高的單日銷售額（The highest sales amount in a single day），同時也想知道哪一個員工的單日銷售筆數最高（the most sales in a single day）（不紀錄 `amount` 為 `0` 的帳單）。寫一個（或是兩個）SQL 查詢來取得這兩種資訊。

**NOTE**: `date()` 函數可以取得日期格式值的"年月日"部分

**NOTE**: 使用 `payment` 表

<details>
    <summary>參考答案</summary>

```sql
SELECT
    staff_id,
	DATE(payment_date),
	SUM(amount),
	COUNT(amount)
FROM payment
WHERE amount <> 0
GROUP BY staff_id, DATE(payment_date)
-- 使用 SUM(amount) 排序即可輕鬆得知最高的單日銷售額
-- 使用 COUNT(amount) 或 COUNT(*) 排序即可輕鬆得知最高的單日銷售筆數
ORDER BY COUNT(amount) DESC;

-- Ans: (兩個答案都是 staff_id = 2 的資料)
-- staff_id date	sum	count
-- 2	"2020-04-30"	2866.42	658
-- 1	"2020-04-30"	2736.75	625
-- 2	"2020-03-21"	1505.52	348
-- 1	"2020-03-01"	1433.58	342
-- ...
-- total rows: 82
```

</details>

<br/>

# Having

對分組搭配聚合函數的結果進行條件篩選的語句，只有使用 `GROUP BY` 的查詢才能使用 `HAVING`（＊註），也就是說 `HAVING` 會**得到查詢結果後**再次過濾才顯示結果。
若要對非分組的結果進行條件篩選的話，請使用 `WHERE`，`WHERE` 才是對基礎資料進行條件篩選的語句，會在**查詢之前**先進行條件篩選。

**NOTE**: （註）實務上不使用 `GROUP BY` 的查詢也能使用，但在使用之前會將搜尋結果視為一個群組，所以事實上也是對分組搭配聚合函數的結果進行條件篩選。

- 用法:

```sql
SELECT <column_name>
FROM <table_name>
GROUP BY <column_name>
HAVING <condition>; -- 在 GROUP BY 之後緊接著使用
```

- 練習:

```sql
SELECT
    staff_id,
	COUNT(amount),
	SUM(amount)
FROM payment
WHERE amount <> 0
GROUP BY staff_id
HAVING COUNT(amount) > 400
ORDER BY COUNT(amount) DESC;
```

- **挑戰 1 - UDEMY**:

Find the cities with more than `two` transactions where the average transaction amount exceeds `$150.00`. List the city and the average transaction amount (AS `AverageAmount`), sorted by the average transaction amount in descending order.

Necessary Information

Table name: `Sales`

Columns to consider: `City`, `Amount`, `TransactionID`

<details>
    <summary>參考答案</summary>

```sql
SELECT
    City,
    AVG(Amount) AS AverageAmount
FROM Sales
GROUP BY City
HAVING 
    COUNT(TransactionID) > 2 
AND
    AverageAmount > 150
ORDER BY COUNT(TransactionID) DESC;
```

</details>

<br/>

- **挑戰 2**:

在 `2020`, `4` 月 `28`, `29`, `30` 日，是收入（`revenue`）的高峰期，我們想知道更多這幾天的資訊，請你協助將資料進行以下處理：

找出以**每位客人與日期分組**的平均帳單金額（`average payment amount grouped by customer and day`），並僅考慮每位客人該日帳單筆數超過 `1` 的資料，將結果使用平均金額以倒序排序顯示。

**NOTE**: 此題建議對平均帳單金額使用別名。


<details>
    <summary>參考答案</summary>

```sql
SELECT
    customer_id,
	Date(payment_date),
	ROUND(AVG(amount), 2) AS average_amount,
	COUNT(*)
FROM payment
WHERE 
    Date(payment_date)
    -- 或使用 IN ('2020-04-28', '2020-04-29', '2020-04-30')
	BETWEEN 
	    '2020-04-28'
	AND 
	    '2020-05-01'
GROUP BY 
    customer_id, 
	Date(payment_date)
HAVING COUNT(*) > 1
ORDER BY average_amount DESC;

-- Ans:（這題答案跟講師不同，經過多次驗證確認可能講師的資料庫有變化，以下答案沒有錯誤）
-- 510	"2020-04-28"	9.49	2
-- 443	"2020-04-28"	9.49	2
-- 245	"2020-04-29"	8.99	2
-- 11	"2020-04-30"	8.49	2
-- ...
```

</details>

<br/>

# 章節挑戰

本章節挑戰是建立新資料庫，為邁入中級階段的準備過程，在未完成之前無法進入後續章節，請按以下步驟進行：

**NOTE**: 由於我們已於最一開始項目配置階段將尚未使用到的腳本匯入到資料庫容器中，僅需透過 psql 互動終端載入對應腳本即可。

1. 在終端機中輸入

    ```sh
    docker exec -it postgres psql -U postgres
    ```

2. 輸入以下指令

    ```psql
    \i /psql_scripts/flight_database.sql
    ```