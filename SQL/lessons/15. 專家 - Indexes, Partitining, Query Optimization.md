# 用戶管理

我們到目前為止的操作都是基於 superuser，擁有所有資料庫權限，有時我們實際場景可能需要提供不同的資料庫權限給他人（職責、不同客戶等等原因）。這時我們就需要用戶管理的技術來控制使用者的權限。

SQL 中的用戶管理可以直接指派權限給指定用戶，也可以基於 RBAC 提供角色權限給用戶。

- 用法:

```sql
CREATE USER <username>
WITH PASSWORD '<password>';

-- 等價於擁有登入權限的角色
-- 但一般很少這樣使用
-- 因為角色一般是提供權限給用戶使用的
-- 所以一般建立角色不會再給予登入權限
CREATE ROLE <role_name>
WITH LOGIN PASSWORD '<password>';

-- 刪除
DROP USER <username>;
DROP ROLE <role_name>;
```

**NOTE**: 建立新用戶預設能對 public schema 建立新物件，以及存取自己建立的新物件，若有必要可以撤銷這個預設權限。


# 權限

以下是常見的物件權限（有些僅適用於 table，有些僅適用於 schema，有的都適用）:

- `SELECT`: Allows reading data from a table, view, or sequence.
- `INSERT`: Allows adding new rows to a table or view.
- `UPDATE`: Allows modifying existing data in a table or view.
- `DELETE`: Allows removing rows from a table or view.
- `EXECUTE`: Allows running a stored procedure or function.
- `REFERENCES`: Allows creating foreign key constraints that refer to a table.
- `ALTER`: Allows modifying the structure of an object (e.g., adding a column to a table).
- `INDEX`: Allows creating indexes on a table.
- `USAGE`: Allows using the object, such as connecting to a database or using a sequence.

以下是常見的資料庫系統權限:

- `CREATE SESSION`: Allows a user to connect to the database.
- `CREATE TABLE`: Allows creating new tables.
- `CREATE USER`: Allows creating new user accounts.
- `ALTER ANY TABLE`: Allows modifying any table in the database.
- `DROP ANY TABLE`: Allows dropping any table in the database.
- `GRANT ANY PRIVILEGE`: Allows granting any privilege to other users or roles.

### 指派權限

- 用法:

```sql
GRANT <privilege> | <role>
ON <database_object> 
TO <user> | <role> | PUBLIC;
```

- 練習:

```sql
GRANT SELECT
ON customer
TO nikolai;

-- 給予指定對象 public 下的所有表的閱讀權限
GRANT SELECT
ON ALL TABLES IN SCHEMA public
-- 若使用 WITH GRANT OPTION，則此對象將獲得給予其他用戶同等權限的權限
TO nikolai [WITH GRANT OPTION];
```

### 撤銷權限

- 用法:

```sql
REVOKE <privilege>
ON <database_object>
FROM <user> | <role> | PUBLIC;

-- 更具體的指定來自誰給予的權限
REVOKE <privilege>
ON <database_object>
FROM <user> | <role> | PUBLIC
GRANTED BY <user> | <role>;

-- 撤銷給予權限的權限
REVOKE GRANT OPTION FOR <privilege>
ON <database_object>
FROM <user> | <role> | PUBLIC
[GRANTED BY <user> | <role>];
```

通常在最一開始建立用戶後，我們會使用:

```sql
-- 先給予用戶特定 schema 的權限
-- 否則後續給予什麼權限都沒有意義，因為看不到任何表
GRANT USAGE
ON SCHEMA <schema_name>
TO <user>;

GRANT SELECT, UPDATE, ...
ON TABLE <table_name>
TO <user>;
```

### 權限完整練習

```sql
-- Create users
CREATE USER ria
WITH PASSWORD 'ria123';

CREATE USER mike
WITH PASSWORD 'mike123';

-- Create roles
CREATE ROLE read_only;
CREATE ROLE read_update;

-- Grant usage (already granted)
GRANT USAGE
ON SCHEMA public
TO read_only;

-- Grant SELECT on tables
GRANT SELECT
ON ALL TABLES IN SCHEMA public
TO read_only;

-- Assign read_only to read_update role
GRANT read_only
TO read_update;

-- Grant all privileges on all tables in public to role
GRANT ALL
ON ALL TABLES IN SCHEMA public
TO read_update;

-- Revoke some privileges
REVOKE DELETE, INSERT
ON ALL TABLES IN SCHEMA public
FROM read_update;

-- Assign role to users
GRANT read_update
TO ria;

-- DROP roles
DROP ROLE mike;

DROP ROLE read_update;

-- Removing dependancies
DROP OWNED BY read_update;
DROP ROLE read_update;
```

- **挑戰 1**:

In this challenge you need to create a user, a role and add privileges.

Your tasks are the following:

1. Create the user mia with password 'mia123'

2. Create the role analyst_emp;

3. Grant SELECT on all tables in the public schema to that role.

4. Grant INSERT and UPDATE on the employees table to that role.

5. Add the permission to create databases to that role.

6. Assign that role to mia and test the privileges with that user.

<details>
    <summary>參考答案</summary>

```sql
CREATE USER mia
WITH PASSWORD 'mia123';

CREATE ROLE analyst_emp;

GRANT SELECT
ON ALL TABLES IN SCHEMA public
TO analyst_emp;

GRANT INSERT, UPDATE
ON TABLE employees
TO analyst_emp;

ALTER ROLE analyst_emp CREATEDB;

GRANT analyst_emp
TO mia;
```

</details>

<br/>

# Index（索引）

資料庫的資料是以 Primary Key (主鍵) 的排序建立的，若我們想搜尋一個非主鍵值，在不考慮任何資料庫優化的機制，傳統上需要進行全表搜尋，這樣會導致搜尋效率極低。建立索引會使用額外的資料結構（例如 Hash-map）來加快搜尋效率，相對的會產生一些代價：額外的資料結構花費的儲存空間、寫入時要額外處理的計算所花費的時間成本。

總結來說，索引為使用者帶來：

- 更快的搜尋效率
- 額外的儲存空間
- 稍微下降的寫入效率

## 類型

SQL 中主要有兩種索引的實現方式:

- B-tree 索引:
    用於高基數（資料重複性低）的資料，是具有自平衡能力的樹狀資料結構。Primary Key 預設就是這種索引。

- Bitmap 索引（**實際上這是臨時性索引策略，用戶無法指定建立這種索引，詳見下方補充**）
    用於低基數（資料重複性高）的資料，是一種用位元陣列來儲存資料的方式，大幅提高了查詢效率，需要的儲存空間相對少很多，缺點是更新和插入會很慢。

    <br/>

    舉例來說:
    
    | row_id | value |
    | --- | --- |
    | 1 | visa |
    | 2 | visa |
    | 3 | visa |
    | 4 | mastercard |
    | 5 | mastercard |

    Bitmap:

    | key | Bit |
    | --- | --- |
    | visa | 1 1 1 0 0 |
    | mastercard | 0 0 0 1 1 |

    可以看出這代表 <key> 的值存在哪些列上。

## 補充資訊

```sql
USING <index_type>
-- 以下是實際上支援的索引類型
-- 注意: 上面提到的 bitmap 索引在 postgres 中是臨時性索引，用戶無法指定建立這種索引
```

- **B-Tree (`btree`)**

  - __這是預設選項__，也是最常用的一種。如果在 `CREATE INDEX` 時不指定 `USING` 子句，用的就是 B-Tree。
  - __適用場景__: 幾乎所有常規的比較操作，包括等於 (`=`)、大於 (`>`)、小於 (`<`)、大於等於 (`>=`)、小於等於 (`<=`)，以及 `BETWEEN` 和 `IN`。它是資料庫的萬用索引。

- **Hash (`hash`)**

  - **適用場景**: 只支援「等於 (`=`)」比較。對於等值查詢，它的理論速度比 B-Tree 快，且索引體積更小。
  - **注意事項**: 在舊版的 PostgreSQL 中不建議使用，因為它不是 crash-safe 的。但在新版中已經改進，不過 B-Tree 通常仍然是更泛用、更可靠的選擇。

- **GIN (`gin`) - Generalized Inverted Index**

  - **適用場景**: 用於索引「複合值」或「包含性」的資料類型，也就是一個欄位裡包含多個值。

  - **最佳範例**:

    - **陣列 (`text[]`, `int[]` 等)**: 快速找出哪些陣列包含某個特定元素。
    - **JSONB**: 快速查詢 JSON 文件中是否包含某個 key 或 value。
    - **全文搜尋 (`tsvector`)**: 快速找出哪些文件包含某個單詞。

- **GiST (`gist`) - Generalized Search Tree**

  - **適用場景**: 這是一個通用的框架，可以用來索引各種複雜的資料結構，特別是那些有「重疊性」的資料。

  - **最佳範例**:

    - **幾何資料 (`point`, `polygon`)**: 快速找出哪些圖形互相重疊，或哪個點在哪個區域內。
    - **全文搜尋**: 也可以用於全文搜尋，但通常 GIN 的效能更好。

- **SP-GiST (`spgist`) - Space-Partitioned GiST**

  - **適用場景**: GiST 的一種變體，適用於「非重疊」且可被空間分割的資料結構，例如四元樹 (quadtrees)、k-d 樹 (k-d trees)。
  - **最佳範例**: 電話號碼前綴、IP 網段等。

- **BRIN (`brin`) - Block Range Index**

  - **適用場景**: 專為**超大型資料表**設計，且表中的資料在物理儲存順序上與其值有高度相關性（例如，按時間順序寫入的日誌表）。
  - **運作方式**: 它只記錄每個「區塊範圍 (Block Range)」內的最大值和最小值。索引本身非常小，但查詢效率極高。



## 建立索引

在建立索引前，需要考慮:

Q. 我們應該替每個行都建立索引嗎？
A. 不應該，建立索引如先前提到是有成本的，包含額外的儲存空間以及寫入與更新的效率下降。

Q. 那什麼樣的情況才適合建立索引？
A. 僅在該行經常需要過濾條件時才建立，特別是要過濾的資料僅佔據整個資料表的小部分。另外對小表的查詢通常是沒必要建立索引的，附帶這些額外開銷所帶來的效益有可能比沒有建立索引還低效，甚至資料庫優化器不會採用索引查詢。總的來說，建立索引的條件應該是:
    
    - 該行經常需要過濾條件
    - 表足夠大
    - 很少在更新的行

- 用法:

```sql
CREATE INDEX index_name
-- 若不指定 index_type，則預設為 btree
ON table_name [USING index_type]
(
    column_name
    [, ...]
);
```

- **挑戰 1 - UDEMY**:

Execute the following query:

```sql
SELECT 
    * 
FROM flights f2
WHERE flight_no < (
    SELECT 
        MAX(flight_no)
    FROM flights f1
    WHERE f1.departure_airport=f2.departure_airport
);
```

This query has a very bad performance.

Test indexes on different columns and compare their performance.

Also consider an index on multiple columns.

此挑戰的問題:

1. On which column(s) would you place an index to get the best performance in the query?

<details>
    <summary>參考答案</summary>

```sql
-- 在不需要考慮建立索引成本的情況下
-- 索引覆蓋所有要查詢的欄位上會使資料庫不必查詢原表，從而得到最快的查詢速度

CREATE INDEX departure_airport_idx
ON flights
(
	flight_no,
	departure_airport
);
```

</details>

<br/>

# 查詢優化

在 pgadmin 中，我們可以使用 Explain Analyze 深度檢視各個指標的數值，以此來了解查詢的性能。在執行一筆查詢時，SQL 查詢優化器會自動選擇最適合的查詢方法路徑（我們無法介入），像是使用索引、建立臨時 bitmap 等等，但大多數性能有明顯問題時，都是需要人工調整的，可能是查詢的複雜度太高或是表的解耦有問題，也有可能是因為資料量太大，這時候就可以仔細思考是否是建立索引能解決的，還是需要重新設計資料表，又或是調整搜尋的方法等等。