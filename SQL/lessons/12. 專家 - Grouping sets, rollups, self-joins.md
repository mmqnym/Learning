# GROUPING SETS

GROUPING SETS 用於當用戶需要對多個分組進行聚合運算時，高效地將結果合併，有助於以各種角度分析資料。

傳統上要將多個分組進行聚合運算的結果合併的方式可能會分成多筆查詢，並填充 `NULL` 值後，使用 UNION ALL 進行合併，但這種查詢效能非常的差，可以使用 GROUPING SETS 來替代。

- 用法:

```sql
SELECT
    a,
    b,
    c,
    SUM(d)
FROM
    <table>
GROUP BY
    GROUPING SETS (
        (a, b, c),
        (a, b),
        (a),
    );
```

- 練習:

```sql
SELECT
    TO_CHAR(payment_date, 'Month') AS month,
    staff_id,
    SUM(amount)
FROM payment
GROUP BY
    GROUPING SETS (
        (staff_id),
        (month),
        (staff_id, month)
    )
ORDER BY 1, 2;
```

- **挑戰 1**:

Write a query that return the sum of the amount for each customer (first name and last name) and each staff_id. Also add the overall revenue per customer.

結果應該如下:

| first_name | last_name | staff_id | sum |
| --- | --- | --- | --- |
| AARON | SELBY | 1 | 63.86 |
| AARON | SELBY | 2 | 46.90 |
| AARON | SELBY | [null] | 110.76 |
| ... | ... | ... | ... |

<details>
    <summary>參考答案</summary>

```sql
SELECT
    first_name,
	last_name,
	staff_id,
	SUM(amount)
FROM customer AS cu
INNER JOIN payment AS p
ON cu.customer_id = p.customer_id
GROUP BY
	GROUPING SETS (
		(first_name, last_name),
		(first_name, last_name, staff_id)
	)
ORDER BY first_name, last_name, staff_id;
```
</details>

<br/>

- **挑戰 2**:

本挑戰建立於上一個挑戰，請使用上一個挑戰的結果加上一行顯示各客戶對員工的收入占比，如下所示：

| first_name | last_name | staff_id | sum | percentage |
| --- | --- | --- | --- | --- |
| AARON | SELBY | [null] | 110.766 | 100 |
| AARON | SELBY | 2 | 46.90 | 42.34 |
| AARON | SELBY | 1 | 63.8 | 57.66 |
| ... | ... | ... | ... | ... |

<details>
    <summary>參考答案</summary>

```sql
SELECT
    first_name,
	last_name,
	staff_id,
	SUM(amount),
	ROUND(
		SUM(amount)
		/
		FIRST_VALUE(SUM(amount)) OVER(PARTITION BY first_name, last_name ORDER BY SUM(amount) DESC)
		*
		100,
		2
	) AS percentage
FROM customer AS cu
INNER JOIN payment AS p
ON cu.customer_id = p.customer_id
GROUP BY
	GROUPING SETS (
		(first_name, last_name),
		(first_name, last_name, staff_id)
	)
ORDER BY first_name, last_name, staff_id DESC;
```
</details>

<br/>

# ROLLUP

ROLLUP 用於對有層次性的資料進行分組（自動產生 GROUPING SETS），使結果容易分析。

所謂的有層次性的資料就是每個群組必定包含下一個群組的資料。

舉例來說：年、月、日，每個年都必定包含月的資料，每個月也都必定包含日的資料。

- 用法:

```sql
-- 順序很重要
-- 需以大群組到小群組的順序排列

SELECT
    a,
    b,
    c,
    SUM(d)
FROM
    <table>
GROUP BY
    ROLLUP (
        a,
        b,
        c
    );

-- 等價於:

SELECT
    a,
    b,
    c,
    SUM(d)
FROM
    <table>
GROUP BY
    GROUPING SETS (
        (a, b, c),
        (a, b),
        (a),
        ()
    )
```

- 練習:

```sql
SELECT
    'Q' || TO_CHAR(payment_date, 'Q') AS quarter,
    EXTRACT(month from payment_date) AS month,
    DATE(payment_date),
    SUM(amount)
FROM payment
GROUP BY
    ROLLUP (
        'Q' || TO_CHAR(payment_date, 'Q'),
        EXTRACT(month from payment_date),
        DATE(payment_date)
    )
ORDER BY 1, 2, 3;
```

- **挑戰 1**:

Write a query that calculates a booking amount rollup for the hierarchy of quarters, months, week in month and day.

結果應該如下（以查詢語句為準，答案數值可能因資料庫操作而變更）:

| quarter | month | week_in_month | day | booking_amount |
| --- | --- | --- | --- | --- |
| 2 | 6 | 3 | 2017-06-21 | 662400.00 |
| 2 | 6 | 3 | [null] | 662400.00 |
| 2 | 6 | 4 | 2017-06-22 | 778600.00 |
| 2 | 6 | 4 | 2017-06-23 | 2431700.00 |
| ... | ... | ... | ... | ... |

**HINT**: Pattern for week in month is 'w'

<details>
    <summary>參考答案</summary>

```sql
SELECT
    TO_CHAR(book_date, 'Q') AS quarter,
    EXTRACT(month from book_date) AS month,
	TO_CHAR(book_date, 'w') AS week_in_month,
    DATE(book_date),
    SUM(total_amount) AS booking_amount
FROM bookings
GROUP BY
    ROLLUP (
        TO_CHAR(book_date, 'Q'),
        EXTRACT(month from book_date),
		TO_CHAR(book_date, 'w'),
        DATE(book_date)
    )
ORDER BY 1, 2, 3, 4;
```
</details>

<br/>

# CUBE

CUBE 用於對資料集進行所有可能性分組（自動產生 GROUPING SETS）。

與 ROLLUP 不同的是，CUBE 會產生它包含的行的所有可能性組合，無論它們之間是否存在層次性。

- 用法:

```sql
SELECT
    a,
    b,
    c,
    SUM(d)
FROM
    <table>
GROUP BY
    CUBE (
        a,
        b,
        c
    );

-- 等價於:

SELECT
    a,
    b,
    c,
    SUM(d)
FROM
    <table>
GROUP BY
    GROUPING SETS (
        (a, b, c),
        (a, b),
        (a, c),
        (b, c),
        (a),
        (b),
        (c),
        ()
    )
```

- 練習:

```sql
SELECT
    customer_id,
    staff_id,
    DATE(payment_date),
    SUM(amount)
FROM payment
GROUP BY
    CUBE (
        customer_id,
        staff_id,
        DATE(payment_date)
    )
ORDER BY 1, 2, 3;
```

- **挑戰 1**:

Write a query that returns all grouping sets in all combinations of customer_id, date and title with the aggregation of the payment amount.

The desired result looks like this:

| customer_id | date | title | total |
| --- | --- | --- | --- |
| 1 | 2020-01-25 | PATIENT SISTER | 2.99 |
| 1 | 2020-01-25 | [null] | 2.99 |
| 1 | 2020-01-28 | TALENTED HOMICIDE | 0.99 |
| 1 | 2020-01-28 | [null] | 0.99 |
| 1	| 2020-02-14 | MUSKETEERS WAIT | 5.99 |
| 1	| 2020-02-14 | [null] |	5.99 |
| 1 | 2020-02-15 | DETECTIVE VISION | 0.99 |
| 1 | 2020-02-15 | FERRIS MOTHER | 9.99 |
| ... | ... | ... | ... |

How do you order the output to get that desired result?

<details>
    <summary>參考答案</summary>

```sql
SELECT
    p.customer_id,
	DATE(payment_date),
	title,
	SUM(amount) AS total
FROM payment AS p
INNER JOIN rental AS r
ON p.rental_id = r.rental_id
INNER JOIN inventory AS i
ON r.inventory_id = i.inventory_id
INNER JOIN film AS f
ON i.film_id = f.film_id
GROUP BY
    CUBE (
        p.customer_id,
		DATE(payment_date),
		title
    )
ORDER BY 1, 2, 3;
```
</details>

<br/>

# Self-join

Self join 並不是一個特別的技術，單純只是對同一個表進行自我引用。

- 用法:

```sql
SELECT
    t1.<column>,
    t2.<column>
FROM <table> t1
INNER JOIN <table> t2
ON t1.<column> = t2.<column>;
```

- 練習:

```sql
SELECT
    e1.first_name,
    e1.last_name,
    e2.first_name,
    e2.last_name
FROM employees AS e1
INNER JOIN employees AS e2
ON e1.reports_to = e2.employee_id;
```

- **挑戰 1**:

Find all the pairs of films with the same length.

| title | title | length |
| --- | --- | --- |
| MUSCLE BRIGHT | SOLDIERS EVOLUTION | 185 |
| MUSCLE BRIGHT | HOME PITY | 185 |
| MUSCLE BRIGHT | DARN FORRESTER | 185 |
| ... | ... | ... |

**NOTE**: 答案不應該包含如下的資料，兩個 title 相同並不算是 `pair`:

| title | title | length |
| --- | --- | --- |
| MUSCLE BRIGHT | MUSCLE BRIGHT | 185 |

<details>
    <summary>參考答案</summary>

```sql
SELECT
	f1.title,
	f2.title,
	f1.length
FROM film AS f1
INNER JOIN film AS f2
ON 
	f1.length = f2.length
	AND 
	f1.title <> f2.title
ORDER BY f1.length DESC;
```
</details>

<br/>

# CROSS JOIN

CROSS JOIN 的功能是取得表與表的笛卡爾積，意味著取得表與表的所有列組合。

例如有以下兩表：

| letter |
| --- |
| A |
| B |

| number |
| --- |
| 1 |
| 2 |
| 3 |

那麼這兩個表進行 CROSS JOIN 的結果就是:

| letter | number |
| --- | --- |
| A | 1 |
| A | 2 |
| A | 3 |
| B | 1 |
| B | 2 |
| B | 3 |

- 用法:

```sql
SELECT
    <table1>.<column>,
    <table2>.<column>
FROM <table1>
CROSS JOIN <table2>;
-- 不需要 ON，因為它們之間不必有關聯性
```

- 練習:

```sql
SELECT
    staff_id,
    store.store_id
FROM staff
CROSS JOIN store;
```

# NATURAL JOIN

NATURAL JOIN 的功能是直接搜尋相同的 colume 名稱來連結兩個表，不需要指定 ON 條件。

通常用於節省打字時間，不過會有一個使用者需要注意的地方，那就是**必須確保兩個表相同的 colume 值能夠對應**，有些情況是兩個表具有超過一個以上的相同 colume，其中一個 colume 的值範圍相同，但另一個不同，此時返回的結果就會是空的。

舉例來說:

表 A 與 B 皆具有 `address_id`, `update_at`，其中 `address_id` 值範圍相同，但 `update_at` 兩表的值完全沒有相同的，這時透過 NATURAL JOIN 會返回空的結果。