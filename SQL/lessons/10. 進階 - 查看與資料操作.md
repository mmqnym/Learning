# 查看與資料操作

本篇將主要介紹關於資料的 UPDATE、DELETE 等操作。

# UPDATE

UPDATE 是一種修改資料的操作，可以用來更新指定的欄位資料。

- 用法:

```sql
UPDATE <table_name>
SET <column_name> = <new_value>
```

- 練習:

```sql
UPDATE songs
SET genre = 'Country music'
-- 一般都會加上過濾條件，因為比較少有想要更新一整行資料的情況
WHERE song_id = 4;

UPDATE customer
SET email = LOWER(email);
```

- **挑戰 1**:

Update all rental rates that are 0.99 to 1.99.

<details>
    <summary>參考答案</summary>

```sql
UPDATE film
SET rental_rate = 1.99
WHERE rental_rate = 0.99;
```
</details>

<br/>

- **挑戰 2**:

The customer table needs to be altered as well:

1. Add the column initials (VARCHAR(10))
2. Update the values to the actual initials for example Frank Smith should be F.S.

<details>
    <summary>參考答案</summary>

```sql
ALTER TABLE customer
ADD COLUMN initials VARCHAR(10);

UPDATE customer
SET initials = LEFT(first_name, 1) || '.' || LEFT(last_name, 1);
```
</details>

<br/>

# DELETE

DELETE 是一種刪除資料的操作，可以用來刪除指定的資料。

＊通常業務上較少會使用 DELETE 來刪除資料，因為刪除資料可能會導致關聯資料的不一致性，加上大多業務情境需要保留一定時間內的歷史紀錄。

- 用法:

```sql
DELETE FROM <table_name>
WHERE <condition>;
```

- 練習:

```sql
DELETE FROM songs
WHERE song_id = 4;

DELETE FROM songs
WHERE song_id IN (3, 4);

DELETE FROM songs
WHERE song_id IN (3, 4)
RETURNING song_id; -- 回傳刪除的 song_id    

DELETE FROM songs
WHERE song_id IN (3, 4)
RETURNING *; -- 回傳刪除的完整資料
```

- **挑戰 1**:

Delete the row in the payment table with payment_id 17064 and 17067.

<details>
    <summary>參考答案</summary>

```sql
DELETE FROM payment
WHERE payment_id IN (17064, 17067)
RETURNING *;
```
</details>

<br/>

# CREATE TABLE AS

CREATE TABLE AS 是一種創建資料表的操作，可以用來創建一個新的資料表，並將原始資料表的資料複製到新的資料表中。

- 用法:

```sql
CREATE TABLE <new_table_name> 
AS
SELECT <columns>
FROM <original_table_name>
WHERE <condition>;
```

- 練習:

```sql
CREATE TABLE customer_address
AS
SELECT first_name, last_name, email, address, city
FROM customer AS c
LEFT JOIN address AS a
ON c.address_id = a.address_id
LEFT JOIN city AS ci
ON a.city_id = ci.city_id;
```

- **挑戰 1**:

建立一個表，其中應包含以下資訊（以下表格僅為範例，非正確答案）:

| name | total_amount |
| --- | --- |
| JONATHAN SCARBOROUGH | 72.82 |
| TRACY BARRETT | 118.73 |
| RUSSELL BRINSON | 136.64 |
| ...| ... |

<details>
    <summary>參考答案</summary>

```sql
CREATE TABLE customer_total_amount
AS
SELECT 
	first_name || ' ' || last_name AS name,
	SUM(amount) AS total_amount
FROM
	customer AS c
INNER JOIN
	payment AS p
ON
	c.customer_id = p.customer_id
GROUP BY
	name;
```
</details>

<br/>

# CREATE VIEW

CREATE TABLE AS 可以用來創建一個方便使用者查詢的表，但有一些要考慮的部分，就是這個表需佔用額外的物理存儲，因為它已經被獨立儲存了。另一個問題是這個表並不會因為原本組成的表變動而變動，因為它已經是獨立的表了。

為此，若不希望這些問題影響到我們，可以考慮使用 VIEW 來取代，它只於記憶體儲存邏輯語句，就像是用一個變數紀錄這個語句，因此每次查詢時都會執行這個語句，這樣原本組成的表若變動也會跟著變動，也不會佔用額外的物理空間，相對的缺點就是若原本的查詢很慢，那這個查詢也會很慢，因為 V 儲存的是語句而不是結果。

- 用法:

```sql
CREATE VIEW <view_name>
AS
SELECT <columns>
FROM <table_name>
WHERE <condition>;
```

- **挑戰 1**:

Create a view called films_category that shows a list of the film titles including their title, length and category name ordered descendingly by the length.

Filter the results to only the movies in the category 'Action' and 'Comedy'.

<details>
    <summary>參考答案</summary>

```sql
CREATE VIEW films_category
AS
SELECT
	title,
	length,
	name AS category_name
FROM
	film AS f
INNER JOIN film_category AS fc
ON f.film_id = fc.film_id
INNER JOIN category AS c
ON fc.category_id = c.category_id
WHERE name IN ('Action', 'Comedy')
ORDER BY length DESC;
```
</details>

<br/>

# CREATE MATERIALIZED VIEW（物化視圖）

物化視圖是一個持久化**快取** VIEW 的東西，它會儲存**搜尋結果**到**物理儲存**中，與表非常相似，不同之處在於，物化視圖不得新增修改或是刪除資料，只能用更新的方式來取得原本依賴的語句得出的最新搜尋結果，能對其修改的只有刪除整個物化視圖。

**NOTE**: 它儲存的是 **搜尋結果** 的快取，因此不刷新物化視圖的話，它的來源依賴就算改變也不會影響物化視圖。

- 用法:

```sql
-- 建立
CREATE MATERIALIZED VIEW <view_name>
AS
SELECT <columns>
FROM <table_name>
WHERE <condition>;

-- 更新
REFRESH MATERIALIZED VIEW <view_name>;
```

- 練習:

```sql
-- 通常建立物化視圖時，習慣加上 mv_ 前綴
CREATE VIEW mv_films_category
AS
SELECT
	title,
	length,
	name AS category_name
FROM
	film AS f
INNER JOIN film_category AS fc
ON f.film_id = fc.film_id
INNER JOIN category AS c
ON fc.category_id = c.category_id
WHERE name IN ('Action', 'Comedy')
ORDER BY length DESC;
```

# 管理 View

## DROP VIEW

- 用法:

```sql
DROP VIEW <view_name>;
DROP MATERIALIZED VIEW <view_name>;
```

## ALTER VIEW

- 用法:

```sql
ALTER VIEW <view_name>
RENAME TO <new_view_name>;

ALTER VIEW <view_name>
RENAME COLUMN <column_name> TO <new_view_name>;

ALTER VIEW <view_name>
AS
SELECT <columns>
FROM <table_name>
WHERE <condition>;

-- 修改視圖僅適用於 VIEW
CREATE OR REPLACE VIEW <view_name>
AS 
SELECT <columns>
FROM <table_name>
WHERE <condition>;
```

- **挑戰 1**:

In this challenge, we use again the view `v_customer_info` that we have previously created:

```sql
CREATE VIEW v_customer_info
AS
SELECT cu.customer_id,
    cu.first_name || ' ' || cu.last_name AS name,
    a.address,
    a.postal_code,
    a.phone,
    city.city,
    country.country
     FROM customer cu
     JOIN address a ON cu.address_id = a.address_id
     JOIN city ON a.city_id = city.city_id
     JOIN country ON city.country_id = country.country_id
ORDER BY customer_id
```
**You need to perform the following tasks:**

1) Rename the view to v_customer_information.

2) Rename the customer_id column to c_id.

3) Add also the `initial` column as the last column to the view by replacing the view.（`first_name` 的第一個字母和 `last_name` 的第一個字母拼接成的字串）

<details>
    <summary>參考答案</summary>

```sql
-- 1
ALTER VIEW v_customer_info
RENAME TO v_customer_information;

-- 2
ALTER VIEW v_customer_information
RENAME COLUMN customer_id TO c_id;

-- 3
CREATE OR REPLACE VIEW v_customer_information
AS
SELECT 
    cu.customer_id AS c_id,
    cu.first_name || ' ' || cu.last_name AS name,
    a.address,
    a.postal_code,
    a.phone,
    city.city,
    country.country,
    LEFT(cu.first_name, 1) || ' ' || LEFT(cu.last_name, 1) AS initials
FROM customer cu
JOIN address a ON cu.address_id = a.address_id
JOIN city ON a.city_id = city.city_id
JOIN country ON city.country_id = country.country_id
ORDER BY c_id
```
</details>

<br/>

# Import & Export Data

## Import

將外部資料檔案到表上

＊表必須先存在，這個步驟不會自動實現。

## Export

將表的資料匯出成各種格式的檔案，大多輸出成 csv。