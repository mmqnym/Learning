# Window Functions（窗口函數）

窗口函數是對表的特定行進行操作的函數，通常是用來結合聚合函數使用，它的特別之處在於它不必實際替資料分組也能使用聚合函數。

**NOTE**: 窗口函數運作於 Where 之後，因此窗口函數的結果不能用在 Where 中，僅能使用子查詢。

- 用法:

```sql
SELECT
    AGG(agg_column) OVER (PARTITION BY partition_column)
--                       |------------window-----------|
FROM <table_name>

-- 總和舉例
SELECT
    [<column_name>, ...]
    SUM(<column_name>) OVER (PARTITION BY <column_name>)
FROM <table_name>
```

- 練習:

```sql
SELECT
    transaction_id,
    payment_type,
    customer_id,
    price_in_transaction,
    COUNT(*) OVER (PARTITION BY customer_id)
FROM sales;

-- 甚至也可以這樣使用
SELECT
    transaction_id,
    payment_type,
    customer_id,
    price_in_transaction,
    -- 將整個表視為一個子視窗
    -- 這樣也可以不必實際分組
    COUNT(*) OVER ()
FROM sales;
```

- **挑戰 1**:

Write a query that returns the list of movies including

- film_id
- title
- length
- category name
- average length of movies in that category

Order the results by `film_id`.

<details>
    <summary>參考答案</summary>

```sql
SELECT
    f.film_id,
	title,
	length,
	name AS category_name,
	ROUND(AVG(length) OVER(PARTITION BY name), 2) AS avg_category_length
FROM film AS f
INNER JOIN film_category AS fc
ON f.film_id = fc.film_id
INNER JOIN category AS c
ON fc.category_id = c.category_id
ORDER BY film_id;
```
</details>

<br/>

- **挑戰 2**:

Write a query that returns all payment details including

- the number of payments that were made by this customer and that amount

Order the results by `payment_id`.

<details>
    <summary>參考答案</summary>

```sql
SELECT
    *,
	COUNT(*) OVER(PARTITION BY customer_id, amount)
FROM payment
ORDER BY payment_id;
```
</details>

<br/>

# OVER() with ORDER BY

在 OVER() 中也可以使用 ORDER BY，具體意義為在窗口函數執行之前對各個群組進行邏輯排序以及定義了聚合運算的範圍。

- 用法:

```sql
SELECT
    AGG(agg_column) OVER (ORDER BY order_column)
FROM <table_name>

-- 結合分組
SELECT
    AGG(agg_column) OVER (
        PARTITION BY partition_column
        ORDER BY order_column
    )
FROM <table_name>
```

- **挑戰 1**:

Write a query that returns the running total of how late the flights are (difference between `actual_arrival` and `scheduled_arrival`) order by `flight_id` including the departure airport.

結果應該如下格式：

| flight_id | departure_airport | sum |
| --- | --- | --- |
| 1 | DME | 00:09:00 |
| 2 | DME | 00:10:00 |
| 3 | DME | 00:14:00 |
| 4 | DME | 00:14:00 |
| ... | ... | ... |

<br/>

As a second query, calculate the same running total but partition also by the departure airport.

結果應該如下格式：

| flight_id | departure_airport | sum |
| --- | --- | --- |
| 20981 | AAQ | 00:02:00 |
| 20982 | AAQ | 00:04:00 |
| 20983 | AAQ | 00:04:00 |
| ... | ... | ... |


<details>
    <summary>參考答案</summary>

```sql
-- 1
SELECT
	flight_id,
	departure_airport,
	SUM(actual_arrival - scheduled_arrival) OVER(
		ORDER BY flight_id
	)
FROM flights;

-- 2
SELECT
	flight_id,
	departure_airport,
	SUM(actual_arrival - scheduled_arrival) OVER(
		PARTITION BY departure_airport
		ORDER BY flight_id
	)
FROM flights;
```
</details>

<br/>

# RANK() and DENSE_RANK()

RANK() 與 DENSE_RANK() 都是用來做排名的函數，它們的具體差別是 RANK() 會跳過重複的數值，而 DENSE_RANK() 不會。例如：

對分數做排名：
如果分數是 \(100, 90, 90, 90, 80\)，則

- RANK() 的排名將會是 \(1, 2, 2, 2, 5\)
- DENSE_RANK() 的排名將會是 \(1, 2, 2, 2, 3\)

- 練習:

```sql
-- rank
SELECT
    f.title,
    c.name,
    f.length
RANK() OVER (
    ORDER BY length
)
FROM film AS f
LEFT JOIN film_category AS fc
ON f.film_id = fc.film_id
LEFT JOIN category AS c
ON fc.category_id = c.category_id

-- dense_rank
SELECT
    f.title,
    c.name,
    f.length
DENSE_RANK() OVER (
    PARTITION BY name
    ORDER BY length
)
FROM film AS f
LEFT JOIN film_category AS fc
ON f.film_id = fc.film_id
LEFT JOIN category AS c
ON fc.category_id = c.category_id
```

- **挑戰 1**:

Write a query that returns the customers' name, the country and how many payments they have. For that use the existing view customer_list.

Afterwards create a ranking of the top customers with most sales for each country. Filter the results to only the top 3 customers per country.

結果應該如下:

| name | country | count | rank |
| --- | --- | --- | --- |
| VERA MCCOY | Afghanistan | 18 | 1 |
| JUNE CARROLL | Algeria | 37 | 1 |
| MARIO CHEATHAM | Algeria | 28 | 2 |
| JUDY GRAY | Algeria | 25 | 3 |
| ... | ... | ... | ... |

<details>
    <summary>參考答案</summary>

```sql
SELECT
	*
FROM (
	SELECT 
		name,
		country,
		COUNT(*),
		RANK() OVER(
			PARTITION BY country 
			ORDER BY COUNT(*) DESC
		)
	FROM customer_list AS cl
	INNER JOIN payment AS p
	ON cl.id = p.customer_id
	GROUP BY name, country
) t
WHERE
	rank BETWEEN 1 AND 3; 
```
</details>

<br/>

# FIRST_VALUE()

用於取得第一個值的函數。

- 用法:

```sql
SELECT
    first_value(<column_name>) OVER (<window_spec>)
FROM <table_name>
```

# LEAD() and LAG()

## LEAD

用於取得當前值的前一個值的函數。

## LAG

用於取得當前值的後一個值的函數。

- **挑戰 1**:

Write a query that returns the revenue of the day and the revenue of the previous day.

Afterwards calculate also the percentage growth compared to the previous day.

結果應該如下:

| sum | day | previous_day | difference | percentage_growth |
| --- | --- | --- | --- | --- |
| 62.86 | 2020-01-24 | [null] | [null] | [null] |
| 563.64 | 2020-01-25 | 62.86 | 500.78 | 796.66 |
| ... | ... | ... | ... | ... |

<details>
    <summary>參考答案</summary>

```sql
SELECT
	SUM(amount),
	DATE(payment_date) AS day,
	LAG(SUM(amount)) OVER(ORDER BY DATE(payment_date)) AS previous_day,
	SUM(amount) - LAG(SUM(amount)) OVER(ORDER BY DATE(payment_date)) AS difference,
	ROUND(
		(SUM(amount) - LAG(SUM(amount)) OVER(ORDER BY DATE(payment_date)))
		/
		LAG(SUM(amount)) OVER(ORDER BY DATE(payment_date)) * 100, 
		2
	) AS percentage_growth
FROM payment
GROUP BY day
ORDER BY day;
```
</details>