# UNION

相較於 JOIN 用於合併 column，UNION 用於合併 row，主要用於合併搜尋結果。

**NOTE**: 需要注意的是，由於 UNION 僅以 row 合併，即使在兩個表或搜尋結果的 column 名稱不同，column 的名稱會以第一個表或搜尋結果的名稱顯示。

**NOTE**: UNION 需要確保兩個合併來源的資料型態以及數量皆相同。

**NOTE**: UNION 確保兩個合併來源即使存在相同資料，結果也不會重複。若想要包含重複資料，可以使用 UNION ALL。

- 用法:

```sql
SELECT * FROM table_a
UNION
SELECT * FROM table_b;
```

```sql
SELECT * FROM table_a
UNION ALL
SELECT * FROM table_b;
```

- 練習:

```sql
SELECT first_name FROM actor
UNION
SELECT first_name FROM customer
ORDER BY first_name;
```

# 子查詢 subqueries

在一個查詢中使用另一個查詢的結果來做搜尋。

**NOTE**: 使用子查詢時，需要確保使用括號來包住子查詢，否則會出現語法錯誤。

**NOTE**: 子查詢並不一定等於兩次查詢，現代資料庫優化器會盡可能優化搜尋性能。

- 用法:

```sql
SELECT * FROM table_a
WHERE column IN (
    SELECT column FROM table_b
)
```

- 練習:

```sql
-- 找出 payment 資料表中的所有資料，並且 amount 大於 payment 資料表的平均值
SELECT
*
FROM payment
WHERE amount > (
    SELECT AVG(amount) FROM payment
)
```

- **挑戰 1**:

使用子查詢取得所有電影（`films`）長度（`length`）高於平均長度的電影清單。

<details>
    <summary>參考答案</summary>

```sql
SELECT * FROM film
WHERE length > (
	SELECT AVG(length) FROM film
);
```
</details>

<br/>

- **挑戰 2**:

Return all the films that are available in the inventory in store 2(`store_id=2`) more than 3 times.

<details>
    <summary>參考答案</summary>

```sql
SELECT
	*
FROM film
WHERE film_id IN (
	SELECT
		film_id
	FROM inventory
	GROUP BY film_id
	HAVING COUNT(*) > 3
);
```
</details>

<br/>

- **挑戰 3**:

取得所有在 `2020-01-25` 有支付帳單（`payment`）紀錄的客戶（`customers`）的名字（`first_name`）與姓氏（`last_name`）。

<details>
    <summary>參考答案</summary>

```sql
SELECT 
	first_name,
	last_name
FROM customer
WHERE customer_id IN (
	SELECT
		customer_id
	FROM payment
	WHERE 
		payment_date BETWEEN '2020-01-25' AND '2020-01-26'
);

-- Ans:
-- "MARY"	"SMITH"
-- "JENNIFER"	"DAVIS"
-- "MARIA"	"MILLER"
-- "CAROL"	"GARCIA"
-- "RUTH"	"MARTINEZ"
-- ...
-- total: 127
```
</details>

<br/>

- **挑戰 4**:

取得所有消費高於 `$30` 的客戶（`customers`）的 `first_name` 和 `email addresses` 清單。

<details>
    <summary>參考答案</summary>

```sql
SELECT 
	first_name,
	email
FROM customer
WHERE customer_id IN (
	SELECT
		customer_id
	FROM payment
	GROUP by customer_id
	HAVING SUM(amount) > 30
);

-- Ans:
-- "MARY"	"MARY.SMITH@sakilacustomer.org"
-- "PATRICIA"	"PATRICIA.JOHNSON@sakilacustomer.org"
-- "LINDA"	"LINDA.WILLIAMS@sakilacustomer.org"
-- ...
-- total: 599
```
</details>

<br/>

- **挑戰 5**:

找出所有來自 `California` （`district`=`California`）並且花費超過 $`100` 的客戶（`customers`）的名字（`first_name`）和姓氏（`last_name`）。

<details>
    <summary>參考答案</summary>

```sql
SELECT
	first_name,
	last_name
FROM 
	customer
WHERE 
	customer_id IN (
		SELECT 
			customer_id
		FROM payment
		GROUP BY customer_id
		HAVING SUM(amount) > 100
	)
	AND
	address_id IN (
		SELECT 
			address_id
		FROM address
		WHERE district = 'California'
	)

-- Ans:
-- "PATRICIA"	"JOHNSON"
-- "BETTY"	"WHITE"
-- "ALICE"	"STEWART"
-- "ROSA"	"REYNOLDS"
-- "KRISTIN"	"JOHNSTON"
-- "CASSANDRA"	"WALTERS"
-- "RENE"	"MCALISTER"	
```
</details>

<br/>

# 在 FROM 中使用子查詢

有時我們會有需要先產出一個表後再對其進行其他近一步操作的需求，此時可以在 FROM 中使用子查詢。

- 練習:

```sql
SELECT
    AVG(total_amount)
FROM (
    SELECT customer_id, SUM(amount) AS total_amount
    FROM payment
    GROUP BY customer_id
) AS subquery; -- 需要注意，當在 FROM 使用子查詢時，要使用別名才是對的語法
```

- **挑戰 1**:

What is the average total amount spent per day (average daily revenue)?

**HINT**: 結果應該如下

| avg_per_day |
| --- |
| 1644.31 |

<details>
    <summary>參考答案</summary>

```sql
SELECT
	ROUND(AVG(daily_amount), 2) AS avg_per_day
FROM (
	SELECT
		DATE(payment_date),
		SUM(amount) AS daily_amount
	FROM
		payment
	GROUP BY
		DATE(payment_date)
) AS daily_amount_t
```
</details>

<br/>

# 在 SELECT 中使用子查詢

子查詢也可以用於 SELECT 中，功能與直接給值類似，只是值會是動態的。

**NOTE**: 返回值必須是單一個值，否則 SQL 會報錯。

- 練習:

```sql
SELECT
    *,
    (
        SELECT amount FROM payment
    )
FROM payment;
```

- **挑戰 1**:

顯示所有帳單（`payment`），並在每列顯示小於最大 `amount` 的差值（`difference`）。

<details>
    <summary>參考答案</summary>

```sql
SELECT
    *,
	(
		SELECT 
			MAX(amount)
		FROM
			payment
	) - amount AS difference
FROM payment;

-- Ans:
-- 16050	269	2	7	1.99	"2020-01-24 22:40:19.996577+01"	10.00
-- 16051	269	1	98	0.99	"2020-01-25 16:16:50.996577+01"	11.00
-- 16052	269	2	678	6.99	"2020-01-28 22:44:14.996577+01"	5.00
-- 16053	269	2	703	0.99	"2020-01-29 01:58:02.996577+01"	11.00
-- 16054	269	1	750	4.99	"2020-01-29 09:10:06.996577+01"	7.00
-- ...
```
</details>