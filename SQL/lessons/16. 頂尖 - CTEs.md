# CTE（Common Table Expressions）

CTE 是一個臨時的結果集，可以在查詢中參考它。CTE 使處理複雜的連接和子查詢時的 SQL 語句更易讀也更容易管理。

# CTE 的優勢

- 提升可讀性：它們能幫助將複雜的查詢分解成更簡單、更易理解的各部分。
- 可重用性：可以在同一個查詢中多次參考 CTE，從而避免重複相同的子查詢。
- 模組化：它們允許採用模組化的方法來建立查詢，從而更容易進行調試和維護。
- 遞迴查詢：CTE 支持遞迴，讓用戶能夠編寫處理階層或樹狀結構數據的查詢。

# 常規用法

- 用法

```sql
WITH cte_name AS (
    -- CTE query
    SELECT column1, column2, ... 
    FROM table_name
    WHERE condition
)
SELECT column1, column2, ...
FROM cte_name
WHERE condition;
```

- 練習

未使用 CTE，找尋被租借超過 30 次的電影的一個例子:
```sql
SELECT
    film_id,
    title,
    rental_count
FROM (
    SELECT
        f.film_id,
        f.title,
        COUNT(r.rental_id) AS rental_count
    FROM film f
    INNER JOIN inventory AS i
    ON f.film_id = i.film_id
    INNER JOIN rental AS r
    ON i.inventory_id = r.inventory_id
    GROUP BY f.film_id, f.title
) AS film_rentals
WHERE rental_count > 30;
```

使用 CTE，將內部子查詢寫成 CTE:

```sql
WITH subquery AS (
    SELECT
        f.film_id,
        f.title,
        COUNT(r.rental_id) AS rental_count
    FROM film f
    INNER JOIN inventory AS i
    ON f.film_id = i.film_id
    INNER JOIN rental AS r
    ON i.inventory_id = r.inventory_id
    GROUP BY f.film_id, f.title
)

SELECT
    film_id,
    title,
    rental_count
FROM subquery
WHERE rental_count > 30;
```

- 更複雜的例子

下面是一個非常複雜的例子（篩選出各個電影的平均租借時間大於全部電影平均租借時間的資料），因為過濾條件也是一個子查詢:

```sql
SELECT
    film_id,
    title,
    rental_duration
FROM (
    SELECT
        f.film_id,
        f.title,
        AVG(r.return_date - r.rental_date) AS rental_duration
    FROM film AS f
    INNER JOIN inventory AS i
    ON f.film_id = i.film_id
    INNER JOIN rental AS r
    ON i.inventory_id = r.inventory_id
    GROUP BY f.film_id, f.title
) AS film_durations
WHERE rental_duration > (
    SELECT
        AVG(rental_duration)
    FROM (
        SELECT
            AVG(r.return_date - r.rental_date) AS rental_duration
        FROM film AS f
        INNER JOIN inventory AS i
        ON f.film_id = i.film_id
        INNER JOIN rental AS r
        ON i.inventory_id = r.inventory_id
        GROUP BY f.film_id, f.title
    ) AS subquery
)
```

下面展示 CTE 方便的地方:

```sql
-- 可以很明顯的分析得出兩個子查詢除了選擇的欄位不同外，都是一樣的
-- 因此可以直接將該子查詢寫成 CTE
-- 再從該 CTE 中選擇不同欄位就可以了
-- 如下的範例，很明顯 CTE 的範例可讀性高了不少

WITH rental_duration_cte AS (
    SELECT
        f.film_id,
        f.title,
        AVG(r.return_date - r.rental_date) AS rental_duration
    FROM film AS f
    INNER JOIN inventory AS i
    ON f.film_id = i.film_id
    INNER JOIN rental AS r
    ON i.inventory_id = r.inventory_id
    GROUP BY f.film_id, f.title
)
SELECT
    film_id,
    title,
    rental_duration
FROM rental_duration_cte
WHERE rental_duration > (
    SELECT
        AVG(rental_duration)
    FROM rental_duration_cte
);
```

- **挑戰 1**:

Using a Simple CTE

- **Objective:**

    Calculate the total rental count and total rental amount for each customer, and list customers who have rented more than the average number of films.



- **Context:**

    In the DVD rental business, we need to understand customer behavior by calculating how many movies each customer has rented and how much they have spent. We will then identify customers who rent movies more frequently than the average customer.



- **Setup:**

    The DVD rental database already includes the following tables:

    - `customer`
    - `rental`
    - `payment`

- **Challenge:**

    1. Create a CTE to calculate the total rental count and total rental amount for each customer.

    2. Use the CTE to filter customers who have rented more than the average number of films.


**Write your SQL query to achieve the above objectives.**

<details>
    <summary>參考答案</summary>

```sql
-- 1.
WITH rental_data_cte AS (
	SELECT
		COUNT(r.rental_id) AS total_rental_count,
		SUM(amount) AS total_rental_amount,
		c.customer_id
	FROM customer AS c
	INNER JOIN payment AS p
	ON c.customer_id = p.customer_id
	INNER JOIN rental AS r
	ON p.rental_id = r.rental_id
	GROUP BY c.customer_id
)

-- 2.
WITH rental_data_cte AS (
	SELECT
		COUNT(r.rental_id) AS total_rental_count,
		SUM(amount) AS total_rental_amount,
		c.customer_id
	FROM customer AS c
	INNER JOIN payment AS p
	ON c.customer_id = p.customer_id
	INNER JOIN rental AS r
	ON p.rental_id = r.rental_id
	GROUP BY c.customer_id
)
SELECT
	customer_id
FROM rental_data_cte
WHERE total_rental_count > (
	SELECT
		AVG(total_rental_count)
	FROM rental_data_cte
);

```
</details>

<br/>

# 使用多個 CTEs

也可以以以下的方式定義多個 CTE:

```sql
WITH cte1 AS (
    -- First CTE
    SELECT
        column1,
        column2,
        ...
    FROM table_name
    WHERE condition
), -- 注意這個逗號，這種使用方式需要以逗號串接
cte2 AS (
    -- Second CTE
    SELECT
        column1,
        column2,
        ...
    FROM cte1
    WHERE condition
),
cte3 AS (
    -- Third CTE
    SELECT
        column1,
        column2,
        ...
    FROM cte2
    WHERE condition
)

SELECT
    column1,
    column2,
    ...
FROM cte3
WHERE condition;
```

- 練習:

```sql
WITH customer_spending_cte AS (
    SELECT 
        c.customer_id, 
        c.first_name, 
        c.last_name,
        SUM(p.amount) AS total_spend
    FROM customer AS c
    JOIN payment AS p
    ON c.customer_id = p.customer_id
    GROUP BY 
        c.customer_id, 
        c.first_name, 
        c.last_name
),

high_spending_customers_cte AS (
    SELECT
        cs.customer_id,
        cs.first_name,
        cs.last_name,
        cs.total_spend
    FROM customer_spending_cte AS cs
    WHERE cs.total_spend > (
        SELECT
            AVG(total_spend)
        FROM customer_spending_cte
    )
)

SELECT
    hsc.customer_id,
    hsc.first_name,
    hsc.last_name,
    hsc.total_spend,
    f.film_id,
    f.title
FROM high_spending_customers_cte AS hsc
JOIN rental AS r
ON hsc.customer_id = r.customer_id
JOIN inventory AS i
ON r.inventory_id = i.inventory_id
JOIN film AS f
ON i.film_id = f.film_id;
```

- **挑戰 1**:

Using Multiple CTEs


- **Objective:**
    
    Calculate the total rental count and total rental amount for each customer, identify customers who have rented more than the average number of films, and list the details of the films they have rented.

- **Context:**
    
    In the DVD rental business, we need to understand customer behavior by calculating how many movies each customer has rented and how much they have spent. We will then identify customers who rent movies more frequently than the average customer and list the details of the films they have rented.

- **Note:**

    High-Rental Customers: Customers who have rented more than the average number of films.

- **Setup:**
    The DVD rental database already includes the following tables:

- `customer`
- `rental`
- `payment`
- `inventory`
- `film`

We will use these existing tables to complete the exercise.

### Challenge:

- Create a CTE to calculate the total rental count and total rental amount for each customer.

- Create a CTE to calculate the average rental count across all customers.

- Create a CTE to identify customers who have rented more than the average number of films (high-rental customers).

- List the details of the films rented by these high-rental customers.

- Write your SQL query (one query) to achieve the above objectives.

<details>
    <summary>參考答案</summary>

```sql
WITH rental_count_and_amount_cte AS (
	SELECT
		COUNT(r.rental_id) AS total_rental_count,
		SUM(amount) AS total_rental_amount,
		c.customer_id
	FROM customer AS c
	INNER JOIN payment AS p
	ON c.customer_id = p.customer_id
	INNER JOIN rental AS r
	ON p.rental_id = r.rental_id
	GROUP BY c.customer_id
),

avg_rental_count_cte AS (
	SELECT
		AVG(total_rental_count) AS avg_rental_count
	FROM rental_count_and_amount_cte
),

high_rental_customers_cte AS (
	SELECT 
		rca.customer_id,
		rca.total_rental_count, 
		rca.total_rental_amount
    FROM rental_count_and_amount_cte AS rca
    INNER JOIN avg_rental_count_cte AS arc 
	ON rca.total_rental_count > arc.avg_rental_count
)

SELECT
	*
FROM rental AS r
INNER JOIN high_rental_customers_cte AS hrc
ON r.customer_id = hrc.customer_id;
```
</details>

<br/>

# Recursive CTEs

遞迴 CTEs 通常用於取得有層級的資料。在滿足一個條件之前，不停的往下持續搜尋，直到滿足條件為止，並將這些結果以 UNION ALL 結合。

**NOTE**: 所謂的有層級的資料類似於每個資料都有一個父資料的關聯。例如:

| id | name | parent_id |
| --- | --- | --- |
| 1 | 'Action' | [null] |
| 2 | 'Animation' | [null] |
| 3 | 'Children' | 2 |
| 4 | 'Classics' | 1 |
| 5 | 'Comedy' | 1 |
| ... | ... | ... |

可以發現每筆資料都與同一張表的資料有上下級的關聯性，稱為層級資料。

- 用法:

```sql
WITH RECURSIVE cte AS (
    -- Base case
    SELECT
        column1,
        column2,
        ...
    FROM table
    WHERE condition
    UNION ALL
    -- Recursive case
    SELECT
        column1,
        column2,
        ...
    FROM cte
    WHERE condition
)
SELECT
    column1,
    column2,
    ...
FROM cte;
```

- 練習:

```sql
WITH RECURSIVE count_cte AS (
    -- 初始值
    SELECT 1 AS number

    UNION ALL

    -- 遞迴與終止條件
    -- 每次 +1 直到到達 10
    SELECT number + 1
    FROM count_cte
    WHERE number < 10
)

-- 呼叫遞迴 CTE
-- 結果是 {1, 2, ..., 10}
SELECT * FROM count_cte;
```

較為實際的範例

```sql
WITH RECURSIVE category_hierarchy_cte AS (
    SELECT
        c.category_id,
        c.name,
        c.parent_category_id
    FROM hierarchical_category AS c
    WHERE c.category_id = 1

    UNION ALL

    SELECT
        c.category_id,
        c.name,
        c.parent_category_id
    FROM hierarchical_category AS c
    INNER JOIN category_hierarchy_cte AS ch
    ON c.parent_category_id = ch.category_id
    -- 有限資料集不一定需要終止條件
    -- 當層級自己遞迴到不能再遞迴時（沒有更深的層級）會自行終止
)

SELECT
    *
FROM category_hierarchy_cte;
```

還有一種常見的終止條件就是自行設定深度:

```sql
WITH RECURSIVE category_hierarchy_cte AS (
    SELECT
        c.category_id,
        c.name,
        c.parent_category_id,
        1 AS depth
    FROM hierarchical_category AS c
    WHERE c.category_id = 1

    UNION ALL

    SELECT
        c.category_id,
        c.name,
        c.parent_category_id,
        ch.depth + 1
    FROM hierarchical_category AS c
    INNER JOIN category_hierarchy_cte AS ch
    ON c.parent_category_id = ch.category_id
    WHERE ch.depth < 2 -- 代表最多遞迴兩次，但初始值是 1，所以只會遞迴一次
)
```

- **挑戰 1**:

Using a Recursive CTE


**Objective:** Create an employee hierarchy table and use a recursive CTE to find all subordinates of a given employee.



**Context:** In a company, employees are managed in a hierarchical structure where each employee may have a manager. We need to find all subordinates of a particular manager, regardless of how many levels down they are in the hierarchy.



**Setup:**

- **Step 1**: Create the `employee` table with hierarchical relationships.

```sql
-- Create the employee table
CREATE TABLE IF NOT EXISTS employee (
    employee_id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    manager_id INTEGER REFERENCES employee(employee_id)
);
 
-- Insert sample data to establish an employee hierarchy
INSERT INTO employee (employee_id, name, manager_id) VALUES
(1, 'Alice', NULL),       -- Alice is the CEO, no manager
(2, 'Bob', 1),            -- Bob reports to Alice
(3, 'Charlie', 1),        -- Charlie reports to Alice
(4, 'David', 2),          -- David reports to Bob
(5, 'Eve', 2),            -- Eve reports to Bob
(6, 'Frank', 3);          -- Frank reports to Charlie
```

**Challenge:**

- Use a recursive CTE to find all subordinates of a given employee.

**Write your SQL query to achieve the above objectives.**

<details>
    <summary>參考答案</summary>

```sql
WITH RECURSIVE subordinate_tree AS (
    SELECT 
		e.employee_id, 
		e.name, 
		e.manager_id, 
		1 AS level
    FROM employee e
    WHERE e.employee_id = 1
    
    UNION ALL
    
    SELECT 
		e.employee_id, 
		e.name, 
		e.manager_id, 
		st.level + 1 AS level
    FROM employee AS e
    INNER JOIN subordinate_tree AS st 
	ON e.manager_id = st.employee_id
)

SELECT * FROM subordinate_tree;
```

</details>

<br/>