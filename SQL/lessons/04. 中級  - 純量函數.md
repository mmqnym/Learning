# Scalar function （純量函數）

與聚合函數不同，純量函數通常返回的行數與原始資料相同，是對每筆資料進行更深入分析所使用。下面將會詳細介紹。

# LENGTH, LOWER, UPPER

- LENGTH 函數用於計算字串的長度
- LOWER 函數用於將字串轉換為小寫
- UPPER 函數用於將字串轉換為大寫

- 練習:

```sql
SELECT
    UPPER(email) AS email_upper,
    LOWER(email) AS email_lower,
    LENGTH(email) AS email_length,
    email
FROM customer
WHERE LENGTH(email) > 37;
```

- **挑戰 1 - UDEMY**:

Write a SQL query to find all reviews for `product_id = 101` where the review text contains the word "great" (case insensitive), and order the results by the length of the review text (from shortest to longest).

Return the `review_id`, `review_text`, and the length of the `review_text` (use alias review_length).

Relevant table: 

`customer_reviews`

<details>
    <summary>參考答案</summary>

```sql
SELECT
    review_id,
    review_text,
    LENGTH(review_text) AS review_length
FROM customer_reviews
WHERE
    product_id = 101
AND
    LOWER(review_text) LIKE '%great%'
ORDER BY LENGTH(review_text) ASC;
```
</details>

<br/>

- **挑戰 2**:

在我們的 email 系統中存在一些問題，姓（`last_name`）或名（`first_name`）只要超過 `10` 個字符就會無法寄出，我們需要找出這些紀錄，並將姓名都以小寫（`lower case`）顯示。

**NOTE**: 使用 `customer` 表

<details>
    <summary>參考答案</summary>

```sql
SELECT
    LOWER(first_name) AS first_name,
    LOWER(last_name) AS last_name,
    LOWER(email) AS email -- 不一定要顯示
FROM customer
WHERE 
    LENGTH(first_name) > 10
OR
    LENGTH(last_name) > 10;
```
</details>

<br/>

# LEFT, RIGHT

用於對字串資料取子字串，分別從左邊或右邊取出指定數量的字元

- 練習:

```sql
SELECT
    -- 取出 email 的前 5 個字元
    LEFT(email, 5) AS email_left,
    -- 取出 email 的後 5 個字元
    RIGHT(email, 5) AS email_right,
    -- 崁套用法取出 email 的前 5 個字元的最後一個字元
    RIGHT(LEFT(email, 5), 1) AS email_left_right,
    email
FROM customer;
```

- **挑戰 1**:

1. 取出 `email` 的後 5 個字元
2. 這些 `email` 皆以 `.org` 結尾，請取出 `.` 的部分

你可以撰寫 `1` 或 `2` 個 SQL 查詢來完成這個挑戰

<details>
    <summary>參考答案</summary>

```sql
SELECT
	-- last 5 char
    RIGHT(email, 5) AS email_left,
	-- get .
    -- 取出 email 的後 4 個字元後再取出第 1 個字元
    LEFT(RIGHT(email, 4), 1) AS email_dot
FROM customer
```
</details>

# Concatenate

在 SQL 中可以使用 `||` 運算子來連接字串

- 練習:

```sql
SELECT
    first_name || ' ' || last_name AS full_name,
    first_name,
    last_name
FROM actor;
```

- **挑戰 1 - UDEMY**:

Write a single SQL query to concatenate the `product name`, `category`, and `price` into a single string for each product, formatted as: `"Product Name - Category: Price"`. Use alias AS product_summary. Ensure the price is prefixed with a dollar sign (`$`), e.g. `$1.99`. Order the results by the `product name` in ascending order.

Available columns: `product_id`, `name`, `category`, and `price` from the `products` table.

<details>
    <summary>參考答案</summary>

```sql
SELECT
    name || ' - ' || category || ': $' || price AS product_summary
FROM products
ORDER BY name ASC;
```
</details>

<br/>

- **挑戰 2**:

你被要求對客戶清單的 `email` 做匿名化，具體會是：

- 將 `email` 除了第 1 個字元外，直到 `@` 為止，僅顯示 `***`。
- 將結果取名為 `anonymized_email`

範例如下：

| email | 匿名化後的 email |
| - | - |
| `ethanwei@sakilacustomer.org` | `e***@sakilacustomer.org` |

**NOTE**: 每個 `email` 都以 `@sakilacustomer.org` 為結尾。

**NOTE**: 你可能會困惑若 `email` 的結構不同（ex: `@gmail.com`, `@outlook.com`）的話該如何解決這樣的問題，將會於這個挑戰之後詳細介紹。

<details>
    <summary>參考答案</summary>

```sql
SELECT
    -- 結尾的部分也可以使用 RIGHT(email, LENGTH('@sakilacustomer.org'))
	LEFT(email, 1) || '***' || '@sakilacustomer.org' AS anonymized_email
FROM customer
```
</details>

<br/>

# Position

在 SQL 中可以使用 `POSITION` 函數來找出字串的位置（`index`），注意取得的 index 與程式語言不同，是從 `1` 開始，不是 `0`。

- 練習:

```sql
SELECT
    POSITION('@' IN email) AS at_mark_index,
    email
FROM customer;

-- 以下的查詢是上面挑戰的更彈性解決方法，支援不同域名的 email
-- 具體做法就是取得 `@` 的 index 後
-- 使用 email 的長度減去 `@` 的 index
-- 這樣就可以得到 `@` 後的字串的長度
-- 再加上 `@` 本身的長度後
-- 從右邊取出算出的長度，就能包含 `@` 後的域名字串
-- 後續會提到 `SUBSTRING` 的用法，可以更簡單的取得 `@` 後的字串
SELECT
    LEFT(email, 1) || 
    '***' || 
    RIGHT(email, (LENGTH(email) - POSITION('@' IN email) + 1)) AS anonymized_email
FROM customer;
```

- **挑戰 1**:

在這個挑戰中，你僅有（僅能使用）客戶（`customer`）的電子信箱地址（`email`）以及姓氏（`last name`），請從 `email` 中提取客戶名字（`first name`），並與 `last name` 合併，它的格式應該要是 `Last name, First name` 的形式。

<details>
    <summary>參考答案</summary>

```sql
SELECT
    last_name || ', ' || LEFT(email, POSITION('.' IN email) - 1) AS full_name
FROM customer;
```
</details>

<br/>

# SUBSTRING

用於對字串資料取出子字串

- 用法：

```sql
SUBSTRING(<string> from start [for length]);
-- [for length] 為可選參數，若不提供則會從 start 開始到原始字串結尾
```

- 練習:

```sql
-- 這個查詢返回了 last name
SELECT 
    email,
    SUBSTRING(email from POSITION('.' IN email) + 1 for LENGTH(last_name)),
FROM customer;
```

- **挑戰 1**:

在這個挑戰中，我們將再次處理匿名化的 email，但這次的格式將更為複雜，請完成以下 `2` 個 SQL 查詢:

1. 將 `email` 的姓（`last name`）與名（`first name`）除了第 1 個字元，以及姓名之間的 `.` 之外，直到 `@` 為止，僅顯示 `***`。

    ex: `M***.S***@sakilacustomer.org`, `P***.J***@sakilacustomer.org`

2. 基於第一題的結果，改為將姓的部分僅顯示最後 `1` 個字元，前面的字元以 `***` 代替。

    ex: `***Y.S***@sakilacustomer.org`, `***A.J***@sakilacustomer.org`

**NOTE**: 請不要直接使用 `first_name` 或 `last_name` 這兩個 column，而是使用 `SUBSTRING` 函數來完成這題。

<details>
    <summary>1. 參考答案</summary>

```sql
SELECT
	SUBSTRING(email from 1 for POSITION('.' IN email) - 1) AS first_name,
	SUBSTRING(email from POSITION('.' IN email) + 1 for LENGTH(last_name)) AS last_name,
	SUBSTRING(email from 1 for 1) || 
	    '***' || 
	    '.' || 
	    SUBSTRING(email from POSITION('.' IN email) + 1 for 1) ||
		'***' ||
		SUBSTRING(email from POSITION('@' IN email))
FROM customer;
```

</details>

<br/>

<details>
    <summary>2. 參考答案</summary>

```sql
SELECT
	SUBSTRING(email from 1 for POSITION('.' IN email) - 1) AS first_name,
	SUBSTRING(email from POSITION('.' IN email) + 1 for LENGTH(last_name)) AS last_name, 
	'***' || 
	    SUBSTRING(email from POSITION('.' IN email) - 1 for 1) ||
	    '.' || 
	    SUBSTRING(email from POSITION('.' IN email) + 1 for 1) ||
		'***' ||
		SUBSTRING(email from POSITION('@' IN email))
FROM customer;
```
</details>

<br/>

# EXTRACT

用於對日期資料取出特定的部分

- date / time 資料類型

  在進行 `EXTRACT` 的講解前，需要先知道在 SQL 中有哪些常見的日期與時間資料類型:

 
  | 類型 | 說明 | 範例 |
  | --- | --- | --- |
  | `date` | 沒有時間的日期 | `2020-01-01` |
  | `time` | 沒有日期的時間（包含/不包含時區） | `01:01:01.123`, `01:01:01.123+08` |
  | `timestamp` | 日期以及時間（包含/不包含時區） | `2020-01-01 01:01:01.123`, `2020-01-01 01:01:01.123+08` |
  | `interval` | 時間間隔 | `01:02:03.456` |

- 用法:

```sql
EXTRACT (field from date/time/interval);
-- field 支援的選項非常多，不必特別去背，需要時再查詢即可
-- 常用的有：
-- YEAR、MONTH、WEEK、DAY、HOUR、MINUTE、SECOND、TIMEZONE、EPOCH（就是秒級的 timestamp ）
```

- 練習:

```sql
SELECT
    EXTRACT(day from rental_date),
    COUNT(*)
FROM rental
GROUP BY EXTRACT(day from rental_date)
ORDER BY COUNT(*) DESC;
```

- **挑戰 1**:

你需要分析帳單並找出：

1. 哪個月（`month`）有最高的帳單總額（`total amount`）？
2. 星期幾（`day of week`）有最高的帳單總額（`total amount`）？（返回結果是 0~6，代表星期日、一、二...到星期六）
3. 哪一位客人（`customer`）在一週內花費最高的金額（`amount`）？

**NOTE**: 當使用 `EXTRACT` 函數時，我們有可能無法確切得知想要的資訊，以第三題為例，我們無法得知是哪一年的資料，因為所有年份都被合併了，後續會講解更為客製化的日期查詢方法。

<details>
    <summary>1. 參考答案</summary>

```sql
SELECT
    EXTRACT(month from payment_date) AS month,
    SUM(amount) AS total
FROM payment
GROUP BY month
ORDER BY total DESC;

-- Ans: 4
```
</details>

<br/>

<details>
    <summary>2. 參考答案</summary>

```sql
SELECT
    EXTRACT(dow from payment_date) AS day_of_week,
    SUM(amount) AS total
FROM payment
GROUP BY day_of_week
ORDER BY total DESC;

-- Ans: 4（星期四）
```
</details>

<br/>

<details>
    <summary>3. 參考答案</summary>

```sql
SELECT
    customer_id,
    EXTRACT(week from payment_date) AS week,
    SUM(amount) AS total
FROM payment
GROUP BY
    customer_id,
    week
ORDER BY total DESC;

-- Ans:
-- 459	18	73.88
-- ...
-- 客戶 459 在某年第 18 周花費最多（73.88）
```
</details>

# TO_CHAR

用於將數值轉換為指定格式的字串，可以解決 `EXTRACT` 只能取得一個欄位值的問題。

- 用法:

```sql
TO_CHAR(value, format);
```

- 練習:

```sql
SELECT
    *,
    EXTRACT(month from payment_date),
    TO_CHAR(payment_date, 'MM-YYYY')
FROM payment;
```

- **挑戰 1**:

你需要計算帳單（`payment`）總額（`total amount`）並將資料以以下形式呈現：

**NOTE**: 你需要自行搜尋要使用哪些 `pattern` 來組合成指定格式。

**NOTE**: 本次挑戰重點在格式，順序與別名都可以自由決定。

1. 

| total amount | day |
| --- | --- |
| 62.86 | Fri, 24/01/2020 |
| 70.81 | Fri, 14/02/2020 |

2. 

| total amount | day |
| --- | --- |
| 62.86 | May, 2020 |
| 70.81 | Jan, 2020 |

3. 

| total amount | day |
| --- | --- |
| 62.86 | Thu, 02:44 |
| 70.81 | Wed, 10:06 |